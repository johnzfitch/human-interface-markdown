<!-- Chunk 31 | Source: 2006-10 Apple Human Interface Guidelines.pdf | Est. Tokens: 1052 -->
<span id="page-30-5"></span>Performance is the perceived measure of how fast or efficient your software is and it is critical to the success of all software. Ifyour software seems slow, users maybe less inclined to buyit. Even software that uses the most optimal algorithms may seem slow if it spends more time processing data than responding to the user.  
<span id="page-30-4"></span><span id="page-30-3"></span>Developers who have experience programming on other platforms (including Mac OS 9) should take the time to learn about the factors that influence performance on Mac OS X. Understanding these factors can help you make better choices in your design and implementation. For an overview of performance factors and links to information on how to identify problems, see *Performance Overview*.  
Here are some performance-related guidelines to keep in mind:  
■ Use metrics to identify performance problems. Nevertryto tune the performance ofyour software based on assumptions. Use the Apple-provided tools, such as Shark, to gather data about where your software is performing poorly. Use that data to isolate problems and fix them. You might also want to create your own tools to gather metrics that are specific to your software.  
High Performance **31 2006-10-03 | © 1992, 2001-2003, 2006 Apple Computer, Inc. All Rights Reserved.**  
- <span id="page-31-8"></span>■ Avoidwaiting until the end ofyour development cycle to do performance tuning. Include specific goals in your productrequirements. Gather baseline metrics earlyand continuegathering metrics during development to measure progress against those goals. If you see performance degrading, take immediate corrective actions to fix the problem.
- Choose modern APIs over legacy APIs. Modern interfaces are built for Mac OS X and take advantage of the latest technologyand design information to deliverthe best possible performance.
- Choose appropriate technologies for the task at hand. For example, Cocoa distributed objects may be easier to use, but if your program needs maximum performance over the network, CFNetwork or BSD sockets may be a better choice. See *CFNetwork Programming Guide*for more information.
- <span id="page-31-9"></span>■ Use threads to improve the responsiveness of your code. Taking advantage of the parallelism offered by threads can offer significant performance advantages, especially on multiprocessor systems. Technical Note TN2028, "Threading [Architectures](http://developer.apple.com/technotes/tn/tn2028.html)" includes an excellent overview of threading architectures. See ["Threads"](#page-59-0) (page 60) for more information.
- <span id="page-31-5"></span>■ Avoid polling the system for information. Polling wastes a significant amount of CPU time and is unnecessary with most modern APIs. Most modern APIs provide asynchronous callback mechanisms to notify you when conditions change or requested data is available. Use these mechanisms instead.
- <span id="page-31-7"></span>■ Eliminate any unnecessary I/O operations. Accessing a hard drive or optical drive is one of the slowest operations you can perform on any computer. Minimizing these operations can improve performance tremendously. See *File-System Performance Guidelines* for more information.
- Optimize your memory usage to take advantage of the Mac OS X virtual memory system. Understanding how virtual memory works in Mac OS X can help you make more efficient use of memory. See *Memory Usage Performance Guidelines* for information about the Mac OS X virtual memory system.
- <span id="page-31-6"></span><span id="page-31-2"></span><span id="page-31-1"></span>■ Avoid loadingresources until theyare actually needed byyour software. Loadingresources early wastes memory and can trigger paging before the resource is ever used. Wait until you need the resource and then cache it as appropriate.
- Use the Mach-O executable format. Mach-O is the native executable format of Mac OS X and is used by all system frameworks. Using the legacy Code Fragment Manager (CFM) executable format requires additional bridging code between your code and system libraries. This bridging incurs a small performance penalty that can add up over time.