<!-- Chunk 20 | Source: 1986-12 Human Interface Guidelines (Final Draft).pdf | Est. Tokens: 1002 -->
The Apple Desktop Interface relies on some distinctive models for programming, some of which are unfamiliar even to experienced programmers.  
To help the programmer make use of this interface, and to carry through in these models, some Apple hardware systems provide an abundance of tools in ROM. The developer derives two major advantages from using ROM-based tools and resources: compatibility and efficiency. The more a program bypasses or replaces these tools and resources, the more likely that sooner or later it will be incompatible with new products or features.  
Although a developer might know a more direct way of getting information or performing an operation, using system-provided features ensures hardware independence. For example, always reference the proper data structures to determine the current size of a screen rather than using the constant values for current hardware.  
The next sections deal with some important programming issues that are at the heart of the Apple Desktop Interface.  
#### Modelessness  
With few exceptions, a given action on the user's part should always have the same result, irrespective of past activities.  
Modes are contexts in which a user action is interpreted differently than the same action would be interpreted in another context. In other words, the same action, when completed in two different modes, results in two different reactions. A mode typically restricts the operations that the user can perform while the mode is in effect.  
Because people don't usually operate modally in real life, dealing with modes in computer environments gives the impression that computers are unnatural and unfriendly.  
A mode is especially confusing when the user enters it unintentionally. When this happens, familiar objects and commands may take on unexpected meanings and the user's habitual actions cause unexpected results.  
Most conventional software uses modes heavily. It's tempting to use modes because they sometimes make programming easier. But if you yield to the temptation too frequently, users will consider using your application a chore rather than a satisfying experience.  
This is not to say that you should never use modes in applications. Sometimes a mode is the best way out of a particular problem. Most of these acceptable modes fall into one of the following categories:  
- Long-term modes, such as doing word processing as opposed to graphics editing. In this sense, each application is a mode.
- Short-term "spring-loaded" modes, in which the user must constantly do something in order to maintain the mode, for example, holding down the mouse button to scroll text or holding down the Shift key to extend a text selection.
- Alert modes, where the user must rectify an unusual situation before proceeding. Keep these modes to a minimum.  
Other modes are acceptable if they do one of the following:  
- They emulate a familiar real-life situation that is itself modal. For example, choosing different tools in a graphics editor resembles the real-life choice of physical drawing tools. MacPaint and other palette-based applications exemplify this use of modes.
- They change only the attributes of something, but not its behavior. The boldface and underline modes of text entry are examples.  
They block most other normal operations of the system to emphasize the modality, as in error conditions incurable through software (for example, a dialog box that disables all menu items except Close).  
If an application uses modes, there must be a clear visual indication of the current mode, and the indicator should be near the object most affected by the mode. A good example is MacPaint's changing pointer, which looks like a pencil, paintbrush, spray can, or eraser, depending on the function ("mode") the user has chosen. It should also be very easy to get into or out of the mode (such as by clicking on a different palette symbol).  
No mode should ever prevent a user from saving a document or quitting the application.