<!-- Chunk 12 | Source: 1985 Apple II Human Interface Guidelines.pdf | Est. Tokens: 1269 -->
The contemporary microcomputer user still may have no previous experience with a program. Therefore, you must dedicate a significant fraction of the programming effort to the creation of an intuitively natural human interface. The program must, in the simplest way possible, anticipate the user's questions and needs and be prepared to answer and fill them the moment they arise. Once the user has become basically familiar with the human interface, if she guesses at an unknown response, she should be correct 95% of the time.  
- \* Keep the external appearance of the program is as simple as possible. The user should not get lost within a maze of branches. (You may safely assume that the first-time user has not read the manual.)
- \* Keep the number of screens and menus to a minimum. One of each is best, as in the Apple II windowing software. The user cannot "get lost" because there is only one place.
- \* If you choose to make the user move, make that movement easy and fluid. Maintain a structure simple enough to allow the user to move from place to place without becoming confused.
- \* Keep displays clean and simple. People need redundancy and reinforcement, so don't create displays so starkly bare that people question their own understanding of what is going on. But do strive to make everything count: layout and graphic design should be tied into and supportive of the task being accomplished. Pose questions that are clear and free of ambiguity.
- \* Provide the user with the tools necessary to work with the program. For example, in a personal finance program, an input requesting annual rent should allow an answer such as 435.00 \* 12 or  $435.00 \times 12$ , and not expect the user to work out the answer in his or her head. (Alternatively, you can provide a "desk accessory" calculator.) If a file name must be selected from the disk, display the valid names.
- \* Match the program to the skill level of the user. If you are doing a pricing program for a shopkeeper, do not ask her what her historic elasticity of demand has been without letting her know what it is and giving her the tools to estimate it. (Also, the question may be unnecessary: the fact that you asked it in a similar program you wrote for a Fortune 500 company is no reason to ask it of a shopkeeper.)  
to perform the task. To reduce subjective time:  
- \* Reduce objective time. Once a program is up and running, identify those parts that are perceivably slow and then do a design and code review. Before carrying out any of the following subjective time hints, look at what you can actually speed up through recoding or simplification.
- \* Speed up those parts of the program that are most obvious to the user. In particular, screen displays should be fast. If you have one letter to change, don't erase the whole display and write it over again. If you cannot work out a way to avoid updating the whole display, don't erase the old one: pad the new one out with blanks. At least the user won't be faced with the constant flashing.
- \* Break long operations into sections. During a long boot operation, put up a title page as soon as possible, so the user has something to do during the remainder of the boot.
- \* React to users' input immediately. A user will interpret any delay of more than a few tenths of a second after pressing Return or otherwise accepting to mean that either the program or the user has made an error. If you need to make a computation, first acknowledge that you have accepted the input.  
In training or educational software, it is doubly important to react immediately to test questions. The greatest retention of knowledge occurs when response occurs either within one second or not until the end of the entire test. Apparently, waiting five to ten seconds for a correct/not correct judgement is so frustrating that people lose involvement with what is going on.  
- \* Carry out housekeeping functions during "dead" time, e.g., between keystrokes
- \* Tell the user how long you will be away if you are going for a while, so he or she can spend the waiting time doing something else
- \* Get all information needed before you go away, so the user needn't sit around to enter information during the process.
- \* Animate the display during long disk or printer operations. The simplest way is to display a growing line of periods. A better way is to display information that is more intellectually engaging, such as track and sector counts. The user needn't understand it or even look at it, but if he or she is bored, it provides something to do. A countdown clock is also a nice touch.
- \* Provide a beep when you come back, so the user needn't stare at the display to avoid loosing time in returning to the task.  
We work in an industry where programmers often spend a significant portion of their days reading commic books during interminable compilations. Because we get so used to this kind of enforced bordom, we often visit it  
upon our users. Increase your sensitivity to this important factor.  
A Planning and Testing Methodology