<!-- Chunk 167 | Source: 2001 Aqua Human Interface Guidelines (Preliminary).pdf | Est. Tokens: 865 -->
- Does the application have the overall Mac OS X "look," including high-quality icons, controls, anti-aliased text, windows, and menus?
- Does the application have the Mac OS X "feel," including window minimization, live scrolling, live window dragging, and sheets?
- If a metaphor is being used, is it suitable for the application? Does the metaphor match a "real" visual and behavioral representation?
- Does the application always provide some indication that an activity is being carried out in response to a command?  
#### **APPENDIX A**  
#### Checklist for Creating Aqua Applications  
- Is suitable feedback provided during task processing? Is the completion of a processing task indicated somehow? Is the duration of the task indicated?
- Is the user always able to find an object or action on the screen? In other words, does your interface follow the see-and-point principle of design?
- Are the operations consistent with the standard elements of the Mac OS X interfaceâ€”that is, if a user is familiar with the Macintosh, will your application seem like familiar territory?
- Do document printouts exactly replicate what the user sees on the screen? In other words, is the application WYSIWYG (what you see is what you get)?
- Is an explanation offered if a particular action cannot be carried out? Are alternatives offered?
- Are there warnings about risky actions? Are there enough warnings without being too many? Are users allowed to back away gracefully from risky territory?
- Does the application feel stable?
- If an operation can be interrupted, do you provide a Cancel or Stop button? Can Escape or Command-period be used to cancel or stop these operations?
- Is your application forgiving and explorable by supporting Undo?
- Do you avoid assigning new behaviors to existing interface elements?
- Do you make all changes clearly visible?
- Do you interpret user's responses consistently?
- Do you use progressive disclosure, as appropriate?
- Is your application pre-emptive without hogging CPU process time?
- If your application has modes, is there a clear visual indication of the current mode? Does the visual indication of the mode appear near the object most affected by the mode? Are there enough landmarks to remind the user what area of the application he or she is in? For example, many graphics applications change the pointer to an eraser in erase mode.
- Have you made a clear, consistent distinction between basic and advanced features?
- Is each mode absolutely necessary? Do the modes within the application properly track the user's own modes? Do users consistently avoid the kind of errors caused by the program being in a mode other than what the user wants or expects? Making a mode visually apparent is no guarantee that the user will  
track it: test the application on users and find out what sorts of mistakes they are making. If the errors are caused by modes, find ways to communicate the modes more clearly, or eliminate them.  
- Can the user save a document or quit an application at any time, unless he or she is in a modal dialog box?
- Are the widest possible range of user activities available at any time? The user should spend most of his or her time being able to interact with the application not waiting for it to complete a process.
- Has all user-visible text been reviewed by a professional writer?
- Does all user-visible text use "curly" apostrophes and quotation marks rather than straight ones?