---
chunk_index: 1051
ref: "d2f073dad95a"
id: "d2f073dad95a98782f4ac04436a22b68036240bcadda95863f211fb7025edd5e"
slug: "chunk-020"
path: "marker/1986-12 Human Interface Guidelines (Final Draft)/chunks/chunk_020.md"
kind: "markdown"
lines: [1, 5]
token_estimate: 279
content_sha256: "173f26987b8bdf98ab21170e2f41c639b3b8073d881a3f9bbd6090aad42282df"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

<!-- Chunk 20 | Source: 1986-12 Human Interface Guidelines (Final Draft).pdf | Est. Tokens: 1002 -->
The Apple Desktop Interface relies on some distinctive models for programming, some of which are unfamiliar even to experienced programmers.  
To help the programmer make use of this interface, and to carry through in these models, some Apple hardware systems provide an abundance of tools in ROM. The developer derives two major advantages from using ROM-based tools and resources: compatibility and efficiency. The more a program bypasses or replaces these tools and resources, the more likely that sooner or later it will be incompatible with new products or features.  
Although a developer might know a more direct way of getting information or performing an operation, using system-provided features ensures hardware independence. For example, always reference the proper data structures to determine the current size of a screen rather than using the constant values for current hardware.  
The next sections deal with some important programming issues that are at the heart of the Apple Desktop Interface.