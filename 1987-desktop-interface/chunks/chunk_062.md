<!-- Chunk 62 | Source: 1987 Apple Human Interface Guidelines - The Apple Desktop Interface.pdf | Est. Tokens: 3149 -->
Commands in menus normaly act on only one object. If <sup>a</sup> command needs more information before it can be performed, it presents <sup>a</sup> dialog box to gather the additional information from the user. The user can tell which commands will use a dialog box to get more information because these commands are followed by an ellipsis (...) in the menu.  
A dialog box is <sup>a</sup> rectangle that may contain text, controls, and icons. There should be some text in the box that indicates which command caused the dialog box to appear and what the function of the box is.  
The user sets controls and fills text fields in the dialog box to provide the needed information. When the application puts up the dialog box, it should set the controls to some default setting and fill in the text fields with default values, if possible. One of the text fields (the "first" field) should be highlighted, so that the user can change its value just by typing in the new value. If all the text fields are blank, there should be an insertion point in the first field.  
In general, dialog boxes should be laid out with the most important information and controls at the top left, working down to the less important information, ending with the default button—the button most likely to be clicked—at the lower right. In Western countries, people are used to reading and writing from left to right and top to bottom, so this is the most natural way to fill in information.  
Editing text fields in a dialog box should conform to the guidelines detailed under "Editing Text" later in this chapter.  
After editing an item, the user has two options:  
- a Pressing the Tab key accepts the changes made to the item and selects the next field in sequence.
- D Clicking in another field accepts the changes made to the previous item and selects the newly clicked field.  
Dialog boxes can be either modal or modeless.  
A modal dialog box is one that the user must explicitly dismiss before doing anything else, such as making a selection outside the dialog box or choosing a command. Figure 3-13 shows an example of a modal dialog box.  
![](images/_page_72_Picture_0.jpeg)  
Figure 3-13 A modal dialog box  
Because it restricts the user's freedom of action, you should use this type of dialog box sparingly. In particular, the user can't choose a menu item while a modal dialog box is up and therefore can do only the simplest kinds of text editing. For these reasons, the main use of a modal dialog box is when it's important for the user to complete an operation before doing anything else.  
A modal dialog box usually has at least two buttons: OK and Cancel. OK dismisses the dialog box and performs the original command according to the information provided. It can be given a more descriptive name than Yes or OK: "Start printing," for example. Cancel dismisses the dialog box and cancels the original command. It should always be called Cancel.  
A dialog box can have other kinds of buttons as well. These may or may not dismiss the dialog box. The **default button** (the most likely choice in the current situation) is doubly outlined to call attention to it. It is usually in the lower-right corner of the box. In Figure 3-13, OK is the default button. The user can activate the default button simply by pressing Return or Enter on the keyboard. If there's no default button, Return and Enter have no effect and the user must click in one of the screen buttons.  
A special type of modal dialog box is one with no buttons. This type of box just informs the user of a situation without eliciting any response. It usually describes the progress of an ongoing operation, then disappears. Because it has no buttons, the user has no way to control or dismiss it. It must remain on the screen long enough for the user to read it.  
A modeless dialog box allows the user to perform other operations without dismissing the dialog box. Figure 3-14 shows an example of a modeless dialog box.  
![](images/_page_72_Picture_7.jpeg)  
Figure 3-14 A modeless dialog box  
A modeless dialog box isdismissed by clicking in the close box or by choosing Close. The dialog box is also dismissed implicitly when the user chooses Quit. The application should remember the contents of the dialog box after the box isdismissed, so that when the application is opened again, the dialog box can be restored exactly as it was.  
Controls work the same way in modeless dialog boxes as in modal dialog boxes, except that buttons never dismiss the dialog box. In this context, the OK button means "go ahead and perform the operation, but leave the dialog box up," whereas the Cancel button usually terminates an ongoing operation.  
A modeless dialog box can also have text fields, which the user can edit with the commands in the Edit menu.  
#### Alerts  
Every user is likely at one time or another to do something that an application can't cope with. Applications occasionally have to call the user's attention to such things as <sup>a</sup> loose mouse connection or lack of paper in the printer. Alerts let applications respond to problems in a consistent way, and in stages according to the severity of the problem, the user's expertise, and the particular history of the problem. The two kinds of alerts are beeps and alert boxes.  
#### Beeps  
Beeps are used for errors that are both minor and immediately obvious. For example, if the user tries to backspace past the left boundary of a text field, the application can simply beep instead of displaying an alert box. So that people who can't hear don't miss the message, all beeps should be accompanied by a flash (rapid inverting) of the menu bar.  
#### Alert boxes  
An alert box resembles a modal dialog box (see Figure 3-13). The only way the user can respond is by clicking buttons or by pressing Enter or Return. Alert boxes might contain dials and buttons but usually not text fields, radio buttons, or check boxes.  
Note the recommended general arrangement of the elements. The icon is at the left, with the message text to the right. The buttons are below the message, with the default button, boldly outlined, at the lower right. The default is the likeliest or safest response, and can be chosen by simply pressing Return or Enter.  
The way to be sure the default button is really "safe" is to word the message carefully. Messages in alert boxes must be brief, informative, and friendly without being misleading. If the alert is warning the user of a serious situation, it must be made clear—not hidden in a polite phrase. Messages should be phrased so that the user can easily answer them, and the wording should reflect the user's point of view, not the programmer's. Figure 3-15 shows an example.  
![](images/_page_74_Figure_4.jpeg)  
Figure 3-15 A typical alert box  
There are three classes of alert boxes, each for a different kind of situation and each having its own icon (Figure 3-16).  
- Note. Provides information about situations that have no drastic effects. The user usually responds by pressing an OK button.
- **Caution.** Calls attention to an operation that may have undesirable results if it's allowed to continue. The user is given the choice to continue or not.
- Stop. Calls attention to a serious problem that requires the user to choose from alternative courses of action.  
![](images/_page_74_Picture_10.jpeg)  
![](images/_page_74_Picture_11.jpeg)  
![](images/_page_74_Picture_12.jpeg)  
Caution  
Figure 3-16 Alert box icons  
An application can define different responses for each of several stages of an alert, so that if the user persists in the same mistake, the application can issue increasingly helpful (or increasingly stern) messages. A typical sequence is for the first two consecutive occurrences of the mistake to result in a beep, and for subsequent occurrences to result in an alert box. This type of sequence is especially appropriate when the mistake is likely to be accidental (for example, when the user chooses Cut when there's no text selection).  
How the buttons in an alert box are labeled depends on the nature of the box. If the box presents the user with a situation in which no alternative actions are available, the box has <sup>a</sup> single button that's labeled OK. Clicking this button means "I've read the alert." If the user is given alternatives, then typically the alert is phrased as a question that can be answered Yes or No. In this case, buttons labeled Yes and No are appropriate, although variations such as Save and Don't Save are also acceptable. OK and Cancel can be used, as long as their meanings aren't ambiguous.  
Generally, it's better to be polite than abrupt, even if it means lengthening the message. The role of the alert box isto be helpful and make constructive suggestions, not to give orders. But its focus is to help the user solve the problem, not to give an academic (no matter how interesting) description of the problem itself. It's important to phrase messages in alert boxes so that users aren't left guessing the real meaning.  
Make alert messages self-explanatory. The user should never have to refer to a manual or reference card to find out what an alert message means. Test your alert messages to be sure they tell the user exactly what needs to be done.  
The best way to make an alert message understandable is to think carefully through the error condition itself. Can the application handle this without an error? Is the error specific enough so that the user can fix the situation? What are the recommended solutions? Can the exact item causing the error be displayed in the alert message?  
#### Desk accessories  
A desk accessory is a program with a relatively limited scope that can be opened while another application is running. Desk accessories can be created to perform a wide range of functions. Some imitate useful objects found on real desktops—the standard Macintosh Note Pad, Alarm Clock, and Calculator, for example. Some (the Chooser, for example) are file- or network-related utilities that users may need to access from within a number of different applications. Some are specific to an application or type of application, such as rulers and other graphics tools that are available only in graphics applications, and spelling checkers that are needed only when a word processing application is being used. There are also "idle" programs that blank out the screen or display special graphics after the computer has been idle for a specified period of time. Figure 3-17 shows some desk accessories on a desktop.  
![](images/_page_76_Picture_2.jpeg)  
Figure 3-17 Some desk accessories  
The user can quickly open one or more desk accessories by choosing them from the Apple menu. Generally, all installed desk accessories can be accessed from the Finder or from any other application, except for desk accessories specific to a particular application or type of application.  
Don't design a full-scale application and implement it as a desk accessory. If it's really an application, treat it as an application. Remember that there is <sup>a</sup> limit on the number of desk accessories that can be installed at one time. On the other hand, if your application is a relatively small one that is useful in a variety of situations, consider making it a desk accessory.  
Desk accessories don't have to be windows, but desk accessories that are windows should behave like windows. The user should be able to move them around the screen and dismiss them by clicking a close box.  
A desk accessory can add one (and only one) menu to the application's menu bar. This menu goes away when the desk accessory is closed. Desk accessories should never interfere with the application's menus.  
If possible, let users install and remove all desk accessories in one standard way. Users should be able to install all Macintosh desk accessories with the standard Font/DA Mover rather than with a special installation program.  
All applications should treat desk accessories in a standard way. If a desk accessory opens a window, that window should remain open on the desktop until the user explicitly closes it or quits the current application. The principle "the user is in control" suggests that an application should not close desk accessories just because the user opens or closes document windows. When help systems are implemented as desk accessories, for example, the user can open and close document windows without losing the help window.  
There's more on desk accessories under the heading "The Apple Menu" in this chapter.