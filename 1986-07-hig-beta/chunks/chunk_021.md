<!-- Chunk 21 | Source: 1986-07 Human Interface Guidelines (Second Beta Draft).pdf | Est. Tokens: 771 -->
A mode is a state that the application user has to "enter" and "leave" (such as the edit or insert mode of many word processing programs). A mode restricts the operations that the user can perform while the mode is in effect. Because people don't usually operate modally in real life, having to deal with modes in computer software reinforces the idea that computers are unnatural and unfriendly. Computer users should never have the feeling that they're being forced to navigate through a series of twisting passages in order to get to another part of the program. All appropriate tools and functions should be immediately available at all times. Using a computer should feel more like a one-room office where all tools are immediately at hand than like a suite where some tools are in one room and other tools are in other rooms.  
Modes are particularly confusing when a user "enters" one unintentionally. When this happens, familiar objects and commands may take on unexpected meanings and the user's habitual actions cause unexpected results.  
Most conventional software uses modes heavily. It's tempting to use modes because they sometimes make programming easier. But if you yield to the temptation too frequently, users will consider using your application a chore rather than a satisfying experience.  
This is not to say that modes are never used in applications. Sometimes a mode is the best way out of a particular problem. Most of these acceptable modes fall into one of the following categories:  
- Long-term modes with a procedural basis, such as doing word processing as opposed to graphics editing. In this sense, each application program is a mode, but consistency between applications makes this acceptable.
- Short-term "spring-loaded" modes, in which the user must constantly do something in order to maintain the mode. Holding down the mouse button or a key is the most common example of this kind of mode.
- Alert modes, where the user must rectify an unusual situation before proceeding. Keep these modes to a minimum.  
Other modes are acceptable if they do one of the following:  
- They emulate a familiar real-life situation that is itself modal, like picking up differentsized paintbrushes in a graphics editor. MacPaint and other palette-based applications are examples of this use of modes.
- They change only the attributes of something, and not its behavior. The boldface and underline modes of text entry are examples.
- They block most other normal operations of the system to emphasize the modality, as in error conditions incurable through software. "There's no disk in the disk drive" is an example.  
If an application uses modes, there must be a clear visual indication of the current mode, and the indicator should be near the object being most affected by the mode. A good example is MacPaint's changing pointer, which looks like a pencil, paintbrush, spray can, eraser, or whatever--depending on the function ("mode") the user has chosen. It should also be very easy to get into or out of the mode (such as by clicking on a palette symbol).